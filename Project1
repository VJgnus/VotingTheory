import random 
import copy
from itertools import combinations

#generating Profiles
def make_IC_profile(num_voters:int , num_alternatives: int):
  alternatives = list (range(num_alternatives))
  random.shuffle(alternatives)
  profile=[]

  for i in range(num_voters):
    random.shuffle(alternatives)
    profile.append(copy.copy(alternatives))
  return profile

def ranked_pairs(profile, num_of_candidates):
    # Create a dictionary to store the number of times each pair of candidates defeats each other
    defeats = {}
    for i in range(num_of_candidates):
        for j in range(num_of_candidates):
            if i == j:
                continue
            defeats[(i, j)] = 0
    # Iterate through the voting profile and compare the preferences of each pair of candidates
    for voter in profile:
        for i in range(num_of_candidates):
            for j in range(num_of_candidates):
                if i == j:
                    continue
                if voter.index(i) < voter.index(j):
                    defeats[(i, j)] += 1
    # Create a list of all possible head-to-head contests between candidates
    contests = list(combinations(range(num_of_candidates), 2))
    # Sort the contests by the number of wins
    contests.sort(key=lambda x: defeats[x], reverse=True)
    # Initialize an empty list to store the beatpath ordering
    beatpath = []
    # Initialize a set to keep track of the candidates that have been added to the beatpath
    added = set()
    # Iterate through the sorted contests and add the winner to the beatpath if they haven't been added yet
    for contest in contests:
        if contest[0] not in added and contest[1] not in added:
            added.add(contest[0])
            beatpath.append(contest[0])
    return beatpath

def broda_winner(profile, num_of_candidates):
    beatpath = ranked_pairs(profile, num_of_candidates)
    return beatpath[0]

def copeland_winner(profile, num_of_candidates):
  # Create a dictionary to store the number of times each candidate defeats each other candidate
  defeats = {}
  for i in range(num_of_candidates):
    defeats[i] = {}
    for j in range(num_of_candidates):
      if i == j:
        continue
      defeats[i][j] = 0

  # Iterate through the voting profile and compare the preferences of each pair of candidates
  for voter in profile:
    for i in range(num_of_candidates):
      for j in range(num_of_candidates):
        if i == j:
          continue
        if voter.index(i) < voter.index(j):
          defeats[i][j] += 1
        elif voter.index(j) < voter.index(i):
          defeats[j][i] += 1

  # Calculate the Copeland score for each candidate
  scores = {}
  for i in range(num_of_candidates):
    scores[i] = sum(defeats[i].values()) - sum(defeats[j][i] for j in defeats[i])

  # Return the candidate with the highest Copeland score
  return max(scores, key=scores.get)

def condorcet_winner(profile, num_of_candidates):
  # Create a dictionary to store the number of times each pair of candidates defeats each other
  defeats = {}
  for i in range(num_of_candidates):
    for j in range(num_of_candidates):
      if i == j:
        continue
      defeats[(i, j)] = 0
      defeats[(j, i)] = 0

  # Iterate through the voting profile and compare the preferences of each pair of candidates
  for voter in profile:
    for i in range(num_of_candidates):
      for j in range(num_of_candidates):
        if i == j:
          continue
        if voter.index(i) < voter.index(j):
          defeats[(i, j)] += 1

  # Check for a Condorcet winner
  for i in range(num_of_candidates):
    condorcet = True
    for j in range(num_of_candidates):
      if i == j:
        continue
      if defeats[(j, i)] > defeats[(i, j)]:
        condorcet = False
        break
    if condorcet:
      return i

  return None

def plurality_winner(profile, num_of_candidates):
  # Create a dictionary to count the number of votes for each candidate
  votes = {}
  for candidate in range(num_of_candidates):
    votes[candidate] = 0

  # Iterate through the voting profile and count the votes for each candidate
  for voter in profile:
    # The first candidate in the voter's preference list gets a vote
    candidate = voter[0]
    votes[candidate] += 1

  # Find the candidate with the highest number of votes
  winner = max(votes, key=votes.get)
  return winner

def main():
    borda_count = 0
    plurality_count = 0
    main_counter = 0
    condorcet_count = 0

    num_of_voters =int(input("Number of Voters in your Election : "))
    num_of_candidates = int(input("Number of candidates in your Election : "))
    num_of_simulations = 10000
    for i in range(num_of_simulations):
      profile = make_IC_profile(num_of_voters, num_of_candidates)
    
      p_winner = plurality_winner(profile, num_of_candidates)
      borda = broda_winner(profile, num_of_candidates)
      cond_winner = condorcet_winner(profile, num_of_candidates)
      cope_winner = copeland_winner(profile,num_of_candidates)

      if cond_winner is not None:
        condorcet_count +=1
        if borda == cond_winner:
          borda_count +=1
        if p_winner == cond_winner:
          plurality_count +=1
      else:
        if borda == p_winner:
          main_counter +=1




    print(f'Plurality winner when condorcet: {plurality_count} ')
    print(f'borda winner when condorcet: {borda_count}  ')
    print(f'Condorcet winner: {condorcet_count}')
    print(f'Condorcet winner is not choosen  but Borda and Plurality choose the same winner : {main_counter} times')
    
if __name__ == "__main__":
  main()
